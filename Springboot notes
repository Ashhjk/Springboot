-----------What is Spring Boot?-------------

Spring Boot is a framework designed to simplify the development of Java-based enterprise applications, particularly web and microservices applications. It is built on top of the Spring Framework and provides a streamlined approach to application development by reducing boilerplate configuration and enabling a faster, easier setup process.
spring framework vs springboot:- actually spring framework is flexible but we have to do a lot of configurations by ourself...but using springboot is much easier as it provide a lot of configurations

------------------Inversion of Control(IoC) and Dependency Injection--------------------------
Inversion of Control (IoC) is a programming principle where the control of object creation and the flow of an application is transferred from the developer to a framework or container. It is one of the foundational concepts of the Spring Framework.It is the principle and the implemantation is using DI.
**in springboot we have many layers like controller ,service ,repository etc..
**In order to access the services from controller , we have to create controller class and then create an object of Service class to use some features of Service .
**If sevice want to work with repo ,imagine there is a service class and we have to create object of repository to use it.
**If we have 1000s of such classes in a project then its not that easy to create objects out of it.For making it easy there comes Inversion of Control(normally we have the control to create objects now we are giving the control to someone else.hence called inversion of control).

**DEPENDENCY INJECTION:Dependency Injection (DI) is a design pattern that allows a class to receive its dependencies from an external source, rather than creating them itself. It is a fundamental concept in frameworks like Spring, enabling the implementation of Inversion of Control (IoC).
**Now when a class need an object we dont have to create new object using new keyword rather ask spring to inject object into the application .
**Types of dependency injection
1. constructor injection
2.setter injection
3.field injection

------------JAR File-------------

    What is it? A file that holds Java programs and libraries.
    Think of it like: A box with tools or apps that you can use on your computer.
    Where is it used? For running standalone Java applications (like a calculator or game).

------------WAR File--------------

    What is it? A file that holds everything needed to run a Java-based website or web app.
    Think of it like: A box with everything to launch a website (code, HTML pages, styles).
    Where is it used? For hosting Java websites or APIs on web servers (like Tomcat).

----------------springboot---------------
**suppose we want 100s of classes,spring is ready to make objects for all these .But in some cases we may not need objects for all the classes.Then we tell spring through configurations to create objects for these these classes.

------------- APPLICATION LAYERS------------
1.Presentation
2.Service
3.Persistence

1. Persistence layer :
we use this layer to interact with database.
We use entities at this level to interact with db using one of the following patterns:
     repository pattern
     Data Access Object(DAO)
------------tomcat server----------------
**when building an application in order to run it we need a tomcat server.In our machine even before running the code we need to install and configure tomcat.
**Springboot takes care of all the configuration problems of building a project in less time.To make app creation easy use springboot.
**Springboot has tomcat embedded in it.
STEPS OF CREATING SPRINGBOOT PROJECT
**spring initializer
**project-maven
**language-java
**springboot- 3.2.5
**packaging-jar
**java-21
**dependencies
      spring web------------if we are creating web applications
      spring jpa------------fdb connectivity
      springboot devtools  ------------  -automatic reload
      lombok
**generate 
**unzip 

Avoid SNAPSHOT versions for production:
    SNAPSHOT versions are not stable releases. They are often used for testing upcoming features and may contain bugs.

Choose the latest stable release for new projects.
    Example: If the latest release is 3.4.0, use it. It includes all the latest features, enhancements, and bug fixes.

*****printing hello world 
package com.example.demo;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class Helloworld {
    @RequestMapping
    public String show()
    {
        return "Hello World";
    }
}
while running this we can see tomcat running on port .on that we can see Hello world

--------------Dependency injection using spring boot-----------

*When we need to have objects for specific classes then inside jvm there is ioc or spring container.Inside spring container these objects are created.
*So when we need to run the application first thing we need is the container.
* SpringApplication.run(ProjectApplication.class, args);   create container
*IoC container is an object and it is of the type ApplicationContext.So object of ApplicationContext need to be made.
*Already the SpringApplication.run returns Application context.So assigning it directly.
 ApplicationContext context = SpringApplication.run(ProjectApplication.class, args);

eg:
Application

package com.project1.project;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class ProjectApplication {

	public static void main(String[] args) {
		ApplicationContext context = SpringApplication.run(ProjectApplication.class, args);
        Dev obj=context.getBean(Dev.class);         //getbean is used to get the object created from context..//Dev.class means which class's object is to be created
		obj.build();
	}

}

Dev.java

package com.project1.project;

import org.springframework.stereotype.Component;

@Component    //write component above the classes to let java know object creation of which all classes are to be handled
public class Dev {
    public void build()
    {
        System.out.println("working on an project");
    }
}

-------------application.properties-------------
to store configuration related info

-------------APACHE MAVEN------------
Apache Maven is a popular build automation and project management tool primarily used for Java projects. It simplifies the process of building, testing, and deploying applications by handling dependencies, project structure, and build lifecycle. Maven uses an XML configuration file (pom.xml) to define project details, dependencies, plugins, and other settings.mvnw is mavens wrappper class
*It helps programmmers manage their projects and all the things needed to build the projects.
*There are differrent levels of dependencies (transitive dependency) required for a project....first the depedencies the project needs,then dependencies of the dependencies,then their dependencies and so on...first,second order..etc..
*Maven takes care of all these dependencies.
*Maven also helps in bulding and testing 

*Maven has three phases
1.Clean phase 
2.Default/Build phase 
3.Site phase 
*each phase has specific goals.
*There is a life cycle which tells about the order of these goals.

1. Clean Phase

The clean lifecycle handles project cleanup before the actual build process begins. It removes files and directories generated by previous builds.
Key Goals:

    pre-clean: Tasks to perform before cleaning, like pre-deletion steps.
    clean: Deletes the output files and directories (e.g., the target/ folder).
    post-clean: Tasks to perform after cleaning, such as logging or additional cleanup.

Command to Execute:

mvn clean
* if we look the target in sidebar of intellij we can see so many stuffs from the previous build. So inorder to clean up all these we can use the above command .Now the target is empty

       compile: Compiles the source code.
         ||
       test: Runs the unit tests using a testing framework (e.g., JUnit).
         ||
       package: Packages the compiled code into distributable formats like .jar or .war.
         ||  
       verify:runs checks and integration tests
This goes in sequence first compile then test then package and then verify.
If we enter the command mvn package then it executes compile test and then package.
Same with the case of any of the phases.
* On entering the command :mvn clean it deletes the target files
* command: mvn compile creates the target file
* mvn test: first compile and create the target file then tests
* mvn package create jar file

--------------MAVEN Workflow -------------
using command to run the project  
   mvn spring-boot:run   //runs the application
-------------APP LAYERS-------------
1.presentation
2.Service
3.Persistence

----------------AUTOWIRED---------------
used to automatically make connection between two classes.Suppose one class need the object of other class then using autowired we can create an instance of the object.

******Dev.Java******

package com.project1.project;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Dev {
    @Autowired   //Field injection(injects dependency directly into the variables)      //automatically connects btw Dev class and Laptop class and creates an                                                                                                    instance of laptop class.
    private Laptop laptop;

    public void build()
    {
        laptop.compile();
    }

}

******Laptop.Java******

package com.project1.project;

import org.springframework.stereotype.Component;

@Component               //to make an object of this class
public class Laptop {
    public void compile()
    {
        System.out.println("compiling....");
    }
}

******ProjectApplication**********

package com.project1.project;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class ProjectApplication {

	public static void main(String[] args) {
		ApplicationContext context = SpringApplication.run(ProjectApplication.class, args);
        Dev obj=context.getBean(Dev.class);  //getbean is used to get the object created from context..//Dev.class means which class's object is to be created
		obj.build();
	}

}

Suppose there is a class Dev and it need a laptop to build or compile.So creating separate laptop class and inside laptop class there is a compile method.
Class Dev require the object of laptop class. Using Autowired we can make connection between the laptop and the dev class automatically.

--------------FIELD INJECTION---------(not good)
@Component
public class Dev {
    @Autowired    //FIELD injection...directly injects the dependencies into variables
    private Laptop laptop;

    public void build()
    {
        laptop.compile();
    }

}

-------------CONSTRUCTOR INJECTION------------(not USING AUTOWIRED)
@Component
public class Dev {
   
    private Laptop laptop;
    public Dev(Laptop laptop)
    {
        this.laptop=laptop;
    }

    public void build()
    {
        laptop.compile();
    }

----------------SETTER INJECTION-------------
@Component
public class Dev {
   
    private Laptop laptop;

    @Autowired    //use autowired for setter injection and field injection
    public void setLaptop(Laptop laptop) {
        this.laptop = laptop;
    }

    public void build()
    {
        laptop.compile();
    }

________________@PRIMARY_______________
If we use Autowired to make connection directly to laptop its like harcoding. Suppose we have an interface called Computer and there are two classes Laptop and Desktop both extends computer . In such a case when both we create the connection to computer it can be Laptop or computer ..so there is a confusion to choose connection to either laptop or desktop as both of them have Component above it and both objects of laptop and desktop are created. In such case use @Primary with the class so that the connection is made with that class only.

----------Computer.interface------------
package com.project1.project;

public interface Computer {
    public void compile();
}

-------------Laptop.java-----------
package com.project1.project;

import org.springframework.stereotype.Component;

@Component        //object of laptop created
public class Laptop implements Computer{
    public void compile()
    {
        System.out.println("compiling....");
    }
}

---------------Desktop.JAva------------

package com.project1.project;

import org.springframework.stereotype.Component;

@Component //object of desktop created
@Primary                //@Primary is used so the connection to Desktop is made
public class Desktop implements Computer{
    public void compile()
    {
        System.out.println("compiling....");
    }
}

----------------Dev.java-------------

package com.project1.project;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Dev {
    @Autowired               //throws error because of confusion
    private Computer comp;

    public void setComp(Computer comp) {
        this.comp = comp;
    }



    public void build()
    {
        comp.compile();
    }

}

-------------------ProjectApplication.java-----------
package com.project1.project;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class ProjectApplication {

	public static void main(String[] args) {
		ApplicationContext context = SpringApplication.run(ProjectApplication.class, args);
        Dev obj=context.getBean(Dev.class);  //getbean is used to get the object created from context..//Dev.class means which class's object is to be created
		obj.build();
	}

}


_____________________@QUALIFIER______________________
We can either use @Primary or use 
@Qualifier("mention the class name with first letter small eg:laptop,desktop") in Dev class


public class Dev {
    @Autowired               //throws error because of confusion
    @Qualifier("laptop")
    private Computer comp;

__________________TYPICAL WEB APP________________
client                 =>frontend

controller
service            => backend
repository

database

**the requests coming from the client side(react) has to be handled by the backend.... for this we use controller..say for eg: in order to handle the requests coming from the home page we can create a java class HomeController.
**what all happening in the front end (adding to cart etc) everything is a request and everything has a url.
**for each url there is corresponding method in the controller.
**So for each url write it in slash using annotation @Requestmapping("/")

_____________@RequestMapping____________

******Homecontroller.java*******

package com.Ashly.simpleWebApp;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Controller      //throws error
public class HomeController {

    @RequestMapping("/")    //url:localhost:8080/    search this in browser
    public String greet()
    {
        return "Hi Ashly";
    }
}

*************SimpleWebAppApplication************

package com.Ashly.simpleWebApp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SimpleWebAppApplication {

	public static void main(String[] args) {
		SpringApplication.run(SimpleWebAppApplication.class, args);
	}

}

________________________@RestController___________________________
1.******error is thrown because when we use the annotation @Controller then requestmapping will look the file named "Hi Ashly" to return.So use @RestController instead.
REST= REPRESENTATIONAL STATE TRANSFER(RETURN DATA FROM SERVER TO CLIENT NOT LAYOUT)

@RestController
public class HomeController {

2.******Another way is u can use @Controller itself but along with @RequestMapping use @ResponseBody to show that u are expecting the body as response

@Controller
public class HomeController {

    @RequestMapping("/")
    @ResponseBody
    public String greet()

3.*******Suppose we need to create about page also then we create another method with requestmapping("/about")

package com.Ashly.simpleWebApp;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HomeController {

    @RequestMapping("/")
    public String greet()
    {
        return "Hi Ashly";
    }

    @RequestMapping("/about")
    public String show()
    {
        return "Welcome to about page";
    }
}

type the url -- localhost:8080/   shows Hi Ashly
and the url localhost:8080/about      shows welcome to about page

4.******we can have multiple controllers also eg: logincontroller class for handling login requests.
But when we have many controllers how will the program knows that the request is in which controller...for that there is a FRONT CONTROLLER in between client and controller.
LoginController.java

package com.Ashly.simpleWebApp;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class LoginController {

    @RequestMapping("/login")
    public String show(){
        return "in login page";
    }
}


_______________FRONT CONTROLLER___________
Front controller knows requests should be mapped to which controllers

5. Suppose we have product controller also. If it returns the data of products then there will be so many information such as prod id, price name etc. ...All these are stored in Product.java.When controller wants data ,then it does not ask data from databse,instead the data come from service.We cant hard code information into the controller layer.

Product.java       //model means it holds data

package com.Ashly.simpleWebApp;

import lombok.Data;

@Data            //part of lombok
public class Product {

    private int prodId;
    private String prodName;
    private int price;

}

6. We can make 3 packages called Controller Service and Repository

_______________CRUD OPERATIONS______________________(SimpleWeb application

REST uses http protocol and it contains certain methods for Create Read Update Delete .They are GET,POST,PUT,DELETE.
Using postman for get request we enter the api url:http://localhost:8080/products.If we wnter this url in google we will get the reponse .
or using postman
it gives the response as json.Shows the time taken in ms and also the amount of data send.

7.*****To get a single product based on the id, we have to create one more method with request mapping with id.

we create a method getproductById...then it should return :from the products a stream is created to filter the products.Then a filter based on for any product p which we get from the stream if the p.getproductId matches with the productId then reuturn findFirst().get() because there will be many products with the same id so return first one with matching id.

http://localhost:8080/products/101
returns data related to that product id


____PRODUCT CONTROLLER____

package com.Ashly.simpleWebApp.controller;

import com.Ashly.simpleWebApp.model.Product;
import com.Ashly.simpleWebApp.Service.ProductService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class ProductController {

    @Autowired
    ProductService service;

    @RequestMapping("/products")
    public List<Product> getProducts() {
        return service.getProducts();
    }

    @RequestMapping("/products/{prodId}")
    public Product getProductById(@PathVariable int prodId){
        return service.getProductById(prodId);
    }
}

_____PRODUCT(MODEL)______

package com.Ashly.simpleWebApp.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.stereotype.Component;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Component
public class Product {

    private int prodId;
    private String prodName;
    private int price;
}

___________PRODUCT SERVICE________

package com.Ashly.simpleWebApp.Service;


import com.Ashly.simpleWebApp.model.Product;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;

@Service
public class ProductService {

    List<Product> products = Arrays.asList(new Product(101, "Iphone", 5000), new Product(102, "Canon Camera", 7000),new Product(103,"Shure Mic",1000));

    public List<Product> getProducts() {
        return products;
    }

    public Product getProductById(int prodId) {
        return products.stream()
                .filter(p -> p.getProdId() == prodId)
                .findFirst().get();
    }
}


8.*****************@Pathvariable 
accepts the value from the path (url) say product id

9.______________jackson library_______________
spring web dependency provide jackson library which converts the java object that we give to json and vice versa
10.*****while doing post operation we first go to controller then go to service.

10______________________POST operation___________________

while doing post operation we create the method in service to add the product and then go to the controller.The order changes.

Service
first we create the method  and then accept the Product  'public void addProduct(Product prod)'....then we have to save this product in the list 'products'
product.add(prod);

Controller
In the controller we have to add a method to add product which return nothing so use void which adds the product prod so give prod as argument .

  @RequestMapping("/products")
    public void addProduct(Product prod)
    {
        service.addProduct(prod);
    }

If we give like this the request mapping for getting list of products is also same ..so there is confusion.Therefore use @Postmapping for post operation and
@GetMapping for  get operation keeping the url same.
We have to use 'new ArrayList' because otherwise list will be immutable and we cant add records in it.



***********PRODUCT CONTROLLER*************

package com.Ashly.simpleWebApp.controller;

import com.Ashly.simpleWebApp.model.Product;
import com.Ashly.simpleWebApp.Service.ProductService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
public class ProductController {

    @Autowired
    ProductService service;

    @GetMapping("/products")
    public List<Product> getProducts() {
        return service.getProducts();
    }

    @GetMapping("/products/{prodId}")
    public Product getProductById(@PathVariable int prodId){
        return service.getProductById(prodId);
    }

    @PostMapping("/products")
    public void addProduct(@RequestBody Product prod)   //we have to use request body also because we are sending the  request from client to server
    {
        service.addProduct(prod);
    }

}

*********PRODUCT SERVICE*********

package com.Ashly.simpleWebApp.Service;


import com.Ashly.simpleWebApp.model.Product;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;

@Service
public class ProductService {

    List<Product> products =  new ArrayList<>(Arrays.asList(new Product(101, "Iphone", 5000), new Product(102, "Canon Camera", 7000),new Product(103,"Shure Mic",1000)));                                //we have to use new ArrayList because otherwise list will be immutable and we cant add records in it.

    public List<Product> getProducts() {
        return products;
    }

    public Product getProductById(int prodId) {
        return products.stream()
                .filter(p -> p.getProdId() == prodId)
                .findFirst().get();
    }
    public void addProduct(Product prod)
    {
        products.add(prod);
    }
}


11. _____________UPDATE_____________
*********CONTROLLER******
@PutMapping("/products")
    public void updateProduct(@RequestBody Product prod)
    {
        service.updateProduct(prod);
    }

************SERVICE**********
  public void updateProduct(Product prod) {
        int index =0;
        for (int i=0;i< products.size();i++)
        {
            if (products.get(i).getProdId()== prod.getProdId())    //need to match with the product id given in json
                index=i;
            products.set(index,prod);
        }
    }

12. _____________DELETE____________
**********CONTROLLER************
@DeleteMapping("/products/{prodId}")
    public void deleteProduct(@PathVariable int prodId)   //here we are not passing any object ..here we are accepting the value so use pathvariable
    {
        service.deleteProduct(prodId);
    }

***************SERVICE************
public void deleteProduct(int prodId) {
        int index =0;
        for (int i=0;i< products.size();i++)
        {                                               //here we have the product id and in order to match it with any of the ids and then if matches giving it  to                                                            index and then deleting it
            if (products.get(i).getProdId()== prodId)
                index=i;
            products.remove(index);
        }
    }

13. _____________SPRING DATA JPA______________
inside the service we actually code the logic ...but here we have hardcoded the data .So instead of hardcoding we can directly connect to the database.
For that we use the repository layer.

************JAVA DATABASE CONNECTIVITY(JDBC)************
to connect java code with database.

********OBJECT RELATIONAL MAPPING ********
In java we represent everything using object.In relational db everything is relations.These objects have values say the object product have the values prod id,name , price etc...In database we have tables with table name coloumn name and records...We have to map these objects with relations.How will we get the details about these tables.
Our table name is the entity class name Product.
Variable name in the entity class is the coloumn name.(prodId,prodName,price)
Objects are rows.
****ORM TOOLS**** = Hibernate,Eclipselink,Mybatis
All these tools have different standards.SO if we need to switch from one tool to another we have to chwnge a lot of code.

*******JPA(JAVA PERSISTENCE API)************
They are certain standards for orm mapping.Hibernate implements this.Similarly Eclipselink implements this in someother way etc...
By using JPA it is easier to switch btw different standards.

Steps:
1.add dependencies in pom.xml
2.add configuration in application.properties
3.create repository package

14. ___________REPOSITORY___________

By using repository we can actually connect to a database.
use annotation @Repository
use interface which extends Jpa repository because we need to use JPA here in repo to make the query simple.
Inside Jpa repository<tablename,datatype of primary key>


*******APPLICATION.PROPERTIES*******

spring.application.name=simpleWebApp

spring.datasource.url=jdbc:postgresql://localhost:5432/Shopping
spring.datasource.username=postgres
spring.datasource.password=Ashly@339
spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.hibernate.ddl-auto=update

spring.jpa.show-sql=true   //if we use this statement we can see the sql queries once we do some operation in postman.

*********ProductRepository********
package com.Ashly.simpleWebApp.Repository;

import com.Ashly.simpleWebApp.model.Product;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ProductRepository extends JpaRepository<Product,Integer> {

}       //rest all will be handled by spring JPA

************Product service***********
package com.Ashly.simpleWebApp.Service;


import com.Ashly.simpleWebApp.Repository.ProductRepository;
import com.Ashly.simpleWebApp.model.Product;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class ProductService {

    @Autowired   //annotation to automatically make connection btw instance of productRepository
    ProductRepository repo;

    public List<Product> getProducts() {
        return repo.findAll() ;   //hardcoded values are changed
    }

    public Product getProductById(int prodId) {
        return repo.findById(prodId).orElse(null);   // or Else is must else there will be error
    }
    public void addProduct(Product prod)
    {
        repo.save(prod);   //same for both add and update ..if no such product then it adds new ..or else update
    }

    public void updateProduct(Product prod) {
        repo.save(prod);
    }

    public void deleteProduct(int prodId) {
        repo.deleteById(prodId);
    }
}

**********Product(model)*********
package com.Ashly.simpleWebApp.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.stereotype.Component;


@Component
@Entity
@Table(name="products") //same as table name in database
public class Product {

    @Id      //mention prodId as primary key
    private int prodId;
    private String prodName;
    private int price;

    public int getProdId() {
        return prodId;
    }

    public void setProdId(int prodId) {
        this.prodId = prodId;
    }

    public String getProdName() {
        return prodName;
    }

    public void setProdName(String prodName) {
        this.prodName = prodName;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }
}

________________________________________________BUILDING AN E-COMMERCE WEBSITE_____________________________________________

1.create application.properties..connect to database
2.Then we have to frame the model...what all should be in the table.
describe the table coloumns datatype etc..
***********Model - Product************
id - primary key
name- string
description -string
price -BigDecimal
category-string
releaseDate-date
available-boolean
quantity - int
  if we use lombok then we can use the annotations @Data, @AllArgsConstructor,@NoArgsConstructor then we dont have to write constructors

3. then go to controller and write the api request and also create an autowire to connect to service.
Write each of the methods in the controller and refer it to the service.
4.In service create an autowire to connect it to repository.Write same methods in controller here also and refer to repository.While referring we have to use built in methods like repo.findAll(),repo.save() etc..
5.In the repository write public interface ProductRepository extends JpaRepository<tablename,primary key>...write nothing inside.
